<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>7.10. Plugins</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="index.html" title="Programmer's Reference Guide">
<link rel="up" href="zend.controller.html" title="Chapter 7. Zend_Controller">
<link rel="prev" href="zend.controller.response.html" title="7.9. The Response Object">
<link rel="next" href="zend.controller.modular.html" title="7.11. Using a Conventional Modular Directory Structure">
<link rel="chapter" href="introduction.html" title="Chapter 1. Introduction to Zend Framework">
<link rel="chapter" href="zend.acl.html" title="Chapter 2. Zend_Acl">
<link rel="chapter" href="zend.auth.html" title="Chapter 3. Zend_Auth">
<link rel="chapter" href="zend.cache.html" title="Chapter 4. Zend_Cache">
<link rel="chapter" href="zend.config.html" title="Chapter 5. Zend_Config">
<link rel="chapter" href="zend.console.getopt.html" title="Chapter 6. Zend_Console_Getopt">
<link rel="chapter" href="zend.controller.html" title="Chapter 7. Zend_Controller">
<link rel="chapter" href="zend.currency.html" title="Chapter 8. Zend_Currency">
<link rel="chapter" href="zend.date.html" title="Chapter 9. Zend_Date">
<link rel="chapter" href="zend.db.html" title="Chapter 10. Zend_Db">
<link rel="chapter" href="zend.debug.html" title="Chapter 11. Zend_Debug">
<link rel="chapter" href="zend.dojo.html" title="Chapter 12. Zend_Dojo">
<link rel="chapter" href="zend.dom.html" title="Chapter 13. Zend_Dom">
<link rel="chapter" href="zend.exception.html" title="Chapter 14. Zend_Exception">
<link rel="chapter" href="zend.feed.html" title="Chapter 15. Zend_Feed">
<link rel="chapter" href="zend.filter.html" title="Chapter 16. Zend_Filter">
<link rel="chapter" href="zend.form.html" title="Chapter 17. Zend_Form">
<link rel="chapter" href="zend.gdata.html" title="Chapter 18. Zend_Gdata">
<link rel="chapter" href="zend.http.html" title="Chapter 19. Zend_Http">
<link rel="chapter" href="zend.infocard.html" title="Chapter 20. Zend_InfoCard">
<link rel="chapter" href="zend.json.html" title="Chapter 21. Zend_Json">
<link rel="chapter" href="zend.layout.html" title="Chapter 22. Zend_Layout">
<link rel="chapter" href="zend.ldap.html" title="Chapter 23. Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="Chapter 24. Zend_Loader">
<link rel="chapter" href="zend.locale.html" title="Chapter 25. Zend_Locale">
<link rel="chapter" href="zend.log.html" title="Chapter 26. Zend_Log">
<link rel="chapter" href="zend.mail.html" title="Chapter 27. Zend_Mail">
<link rel="chapter" href="zend.measure.html" title="Chapter 28. Zend_Measure">
<link rel="chapter" href="zend.memory.html" title="Chapter 29. Zend_Memory">
<link rel="chapter" href="zend.mime.html" title="Chapter 30. Zend_Mime">
<link rel="chapter" href="zend.openid.html" title="Chapter 31. Zend_OpenId">
<link rel="chapter" href="zend.paginator.html" title="Chapter 32. Zend_Paginator">
<link rel="chapter" href="zend.pdf.html" title="Chapter 33. Zend_Pdf">
<link rel="chapter" href="zend.registry.html" title="Chapter 34. Zend_Registry">
<link rel="chapter" href="zend.rest.html" title="Chapter 35. Zend_Rest">
<link rel="chapter" href="zend.search.lucene.html" title="Chapter 36. Zend_Search_Lucene">
<link rel="chapter" href="zend.server.html" title="Chapter 37. Zend_Server">
<link rel="chapter" href="zend.service.html" title="Chapter 38. Zend_Service">
<link rel="chapter" href="zend.session.html" title="Chapter 39. Zend_Session">
<link rel="chapter" href="zend.soap.html" title="Chapter 40. Zend_Soap">
<link rel="chapter" href="zend.test.html" title="Chapter 41. Zend_Test">
<link rel="chapter" href="zend.text.html" title="Chapter 42. Zend_Text">
<link rel="chapter" href="zend.timesync.html" title="Chapter 43. Zend_TimeSync">
<link rel="chapter" href="zend.translate.html" title="Chapter 44. Zend_Translate">
<link rel="chapter" href="zend.uri.html" title="Chapter 45. Zend_Uri">
<link rel="chapter" href="zend.validate.html" title="Chapter 46. Zend_Validate">
<link rel="chapter" href="zend.version.html" title="Chapter 47. Zend_Version">
<link rel="chapter" href="zend.view.html" title="Chapter 48. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Chapter 49. Zend_XmlRpc">
<link rel="appendix" href="requirements.html" title="Appendix A. Zend Framework Requirements">
<link rel="appendix" href="coding-standard.html" title="Appendix B. Zend Framework Coding Standard for PHP">
<link rel="appendix" href="copyrights.html" title="Appendix C. Copyright Information">
<link rel="index" href="the.index.html" title="Index">
<link rel="subsection" href="zend.controller.plugins.html#zend.controller.plugins.introduction" title="7.10.1. Introduction">
<link rel="subsection" href="zend.controller.plugins.html#zend.controller.plugins.writing" title="7.10.2. Writing Plugins">
<link rel="subsection" href="zend.controller.plugins.html#zend.controller.plugins.using" title="7.10.3. Using Plugins">
<link rel="subsection" href="zend.controller.plugins.html#zend.controller.plugins.manipulating" title="7.10.4. Retrieving and Manipulating Plugins">
<link rel="subsection" href="zend.controller.plugins.html#zend.controller.plugins.standard" title="7.10.5. Plugins Included in the Standard Distribution">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">7.10. Plugins</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.controller.response.html">Prev</a> </td>
<th width="60%" align="center">Chapter 7. Zend_Controller</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.controller.modular.html">Next</a>
</td>
</tr>
</table></div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.controller.plugins"></a>7.10. Plugins</h2></div></div></div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.plugins.introduction"></a>7.10.1. Introduction</h3></div></div></div>
<p>
            The controller architecture includes a plugin system that allows
            user code to be called when certain events occur in the controller
            process lifetime.  The front controller uses a plugin broker as a
            registry for user plugins, and the plugin broker ensures that event
            methods are called on each plugin registered with the front
            controller.
        </p>
<p>
            The event methods are defined in the abstract class
            <code class="code">Zend_Controller_Plugin_Abstract</code>, from which user plugin
            classes inherit:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <code class="code">routeStartup()</code> is called before
                    <code class="code">Zend_Controller_Front</code> calls on <a href="zend.controller.router.html" title="7.5. The Standard Router: Zend_Controller_Router_Rewrite">the router</a>
                    to evaluate the request against the registered routes.
                </p></li>
<li><p>
                    <code class="code">routeShutdown()</code> is called after <a href="zend.controller.router.html" title="7.5. The Standard Router: Zend_Controller_Router_Rewrite">the router</a>
                    finishes routing the request.
                </p></li>
<li><p>
                    <code class="code">dispatchLoopStartup()</code> is called before
                    <code class="code">Zend_Controller_Front</code> enters its dispatch loop.
                </p></li>
<li><p>
                    <code class="code">preDispatch()</code> is called before an action is
                    dispatched by <a href="zend.controller.dispatcher.html" title="7.6. The Dispatcher">the
                        dispatcher</a>. This callback allows for proxy or
                    filter behavior. By altering the request and resetting its
                    dispatched flag (via
                    <code class="code">Zend_Controller_Request_Abstract::setDispatched(false)</code>),
                    the current action may be skipped and/or replaced.
                </p></li>
<li><p>
                    <code class="code">postDispatch()</code> is called after an action is
                    dispatched by <a href="zend.controller.dispatcher.html" title="7.6. The Dispatcher">the
                        dispatcher</a>. This callback allows for proxy or
                    filter behavior. By altering the request and resetting its
                    dispatched flag (via
                    <code class="code">Zend_Controller_Request_Abstract::setDispatched(false)</code>),
                    a new action may be specified for dispatching.
                </p></li>
<li><p>
                    <code class="code">dispatchLoopShutdown()</code> is called after
                    <code class="code">Zend_Controller_Front</code> exits its dispatch loop.
                </p></li>
</ul></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.plugins.writing"></a>7.10.2. Writing Plugins</h3></div></div></div>
<p>
            In order to write a plugin class, simply include and extend the
            abstract class <code class="code">Zend_Controller_Plugin_Abstract</code>:
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/Controller/Plugin/Abstract.php';

class MyPlugin extends Zend_Controller_Plugin_Abstract
{
    // ...
}
        </pre>
<p>
            None of the methods of <code class="code">Zend_Controller_Plugin_Abstract</code>
            are abstract, and this means that plugin classes are not forced to
            implement any of the available event methods listed above. Plugin
            writers may implement only those methods required by their
            particular needs.
        </p>
<p>
            <code class="code">Zend_Controller_Plugin_Abstract</code> also makes the request
            and response objects available to controller plugins via the
            <code class="code">getRequest()</code> and <code class="code">getResponse()</code> methods,
            respectively.
        </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.plugins.using"></a>7.10.3. Using Plugins</h3></div></div></div>
<p>
            Plugin classes are registered with
            <code class="code">Zend_Controller_Front::registerPlugin()</code>, and may be
            registered at any time.  The following snippet illustrates how a
            plugin may be used in the controller chain:
        </p>
<pre class="programlisting">&lt;?php
require_once 'Zend/Controller/Front.php';
require_once 'Zend/Controller/Router.php';
require_once 'Zend/Controller/Plugin/Abstract.php';

class MyPlugin extends Zend_Controller_Plugin_Abstract
{
    public function routeStartup(Zend_Controller_Request_Abstract $request)
    {
        $this-&gt;getResponse()-&gt;appendBody("&lt;p&gt;routeStartup() called&lt;/p&gt;\n");
    }

    public function routeShutdown(Zend_Controller_Request_Abstract $request)
    {
        $this-&gt;getResponse()-&gt;appendBody("&lt;p&gt;routeShutdown() called&lt;/p&gt;\n");
    }

    public function dispatchLoopStartup(Zend_Controller_Request_Abstract $request)
    {
        $this-&gt;getResponse()-&gt;appendBody("&lt;p&gt;dispatchLoopStartup() called&lt;/p&gt;\n");
    }

    public function preDispatch(Zend_Controller_Request_Abstract $request)
    {
        $this-&gt;getResponse()-&gt;appendBody("&lt;p&gt;preDispatch() called&lt;/p&gt;\n");
    }

    public function postDispatch(Zend_Controller_Request_Abstract $request)
    {
        $this-&gt;getResponse()-&gt;appendBody("&lt;p&gt;postDispatch() called&lt;/p&gt;\n");
    }

    public function dispatchLoopShutdown()
    {
        $this-&gt;getResponse()-&gt;appendBody("&lt;p&gt;dispatchLoopShutdown() called&lt;/p&gt;\n");
    }
}

$front = Zend_Controller_Front::getInstance();
$front-&gt;setControllerDirectory('/path/to/controllers')
      -&gt;setRouter(new Zend_Controller_Router_Rewrite())
      -&gt;registerPlugin(new MyPlugin());
$front-&gt;dispatch();
        </pre>
<p>
            Assuming that no actions called emit any output, and only one action
            is called, the functionality of the above plugin would still create
            the following output:
        </p>
<pre class="programlisting">
&lt;p&gt;routeStartup() called&lt;/p&gt;
&lt;p&gt;routeShutdown() called&lt;/p&gt;
&lt;p&gt;dispatchLoopStartup() called&lt;/p&gt;
&lt;p&gt;preDispatch() called&lt;/p&gt;
&lt;p&gt;postDispatch() called&lt;/p&gt;
&lt;p&gt;dispatchLoopShutdown() called&lt;/p&gt;
        </pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
                Plugins may be registered at any time during the front
                controller execution. However, if an event has passed for which
                the plugin has a registered event method, that method will not
                be triggered.
            </p></td></tr>
</table></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.plugins.manipulating"></a>7.10.4. Retrieving and Manipulating Plugins</h3></div></div></div>
<p>
            On occasion, you may need to unregister or retrieve a plugin. The
            following methods of the front controller allow you to do so:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <code class="code">getPlugin($class)</code> allows you to retrieve a
                    plugin by class name. If no plugins match, it returns false.
                    If more than one plugin of that class is registered, it
                    returns an array.
            </p></li>
<li><p>
                    <code class="code">getPlugins()</code> retrieves the entire plugin stack.
            </p></li>
<li><p>
                    <code class="code">unregisterPlugin($plugin)</code> allows you to remove
                    a plugin from the stack. You may pass a plugin object, or
                    the class name of the plugin you wish to unregister. If you
                    pass the class name, any plugins of that class will be
                    removed.
            </p></li>
</ul></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.plugins.standard"></a>7.10.5. Plugins Included in the Standard Distribution</h3></div></div></div>
<p>
            Zend Framework includes a plugin for error handling in its standard
            distribution.
        </p>
<div class="sect3" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.plugins.standard.actionstack"></a>7.10.5.1. ActionStack</h4></div></div></div>
<p>
        The <code class="code">ActionStack</code> plugin allows you to manage a stack of
        requests, and operates as a <code class="code">postDispatch</code> plugin. If a
        forward (i.e., a call to another action) is already detected in the
        current request object, it does nothing. However, if not, it checks its
        stack and pulls the topmost item off it and forwards to the action
        specified in that request. The stack is processed in LIFO order.
    </p>
<p>
        You can retrieve the plugin from the front controller at any time using
        <code class="code">Zend_Controller_Front::getPlugin('Zend_Controller_Plugin_ActionStack')</code>.
        Once you have the plugin object, there are a variety of mechanisms you
        can use to manipulate it.
    </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                <code class="code">getRegistry()</code> and <code class="code">setRegistry()</code>.
                Internally, <code class="code">ActionStack</code> uses a
                <code class="code">Zend_Registry</code> instance to store the stack. You can
                substitute a different registry instance or retrieve it with
                these accessors.
        </p></li>
<li><p>
                <code class="code">getRegistryKey()</code> and <code class="code">setRegistryKey()</code>.
                These can be used to indicate which registry key to use when
                pulling the stack. Default value is
                'Zend_Controller_Plugin_ActionStack'.
        </p></li>
<li><p>
                <code class="code">getStack()</code> allows you to retrieve the stack of
                actions in its entirety.
        </p></li>
<li><p>
                <code class="code">pushStack()</code> and <code class="code">popStack()</code> allow you
                to add to and pull from the stack, respectively.
                <code class="code">pushStack()</code> accepts a request object.
        </p></li>
</ul></div>
<p>
        An additional method, <code class="code">forward()</code>, expects a request object,
        and sets the state of the current request object in the front controller
        to the state of the provided request object, and markes it as
        undispatched (forcing another iteration of the dispatch loop).
    </p>
</div>
<div class="sect3" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.plugins.standard.errorhandler"></a>7.10.5.2. Zend_Controller_Plugin_ErrorHandler</h4></div></div></div>
<p>
        <code class="code">Zend_Controller_Plugin_ErrorHandler</code> provides a drop-in
        plugin for handling exceptions thrown by your application, including
        those resulting from missing controllers or actions; it is an
        alternative to the methods listed in the <a href="zend.controller.exceptions.html" title="7.12. MVC Exceptions">MVC Exceptions section</a>.
    </p>
<p>
        The primary targets of the plugin are:
    </p>
<div class="itemizedlist"><ul type="disc">
<li><p>Intercept exceptions raised due to missing controllers or
                action methods</p></li>
<li><p>Intercept exceptions raised within action controllers</p></li>
</ul></div>
<p>
        In other words, the <code class="code">ErrorHandler</code> plugin is designed to
        handle HTTP 404-type errors (page missing) and 500-type errors (internal
        error). It is not intended to catch exceptions raised in other plugins
        or routing.
    </p>
<p>
        By default, <code class="code">Zend_Controller_Plugin_ErrorHandler</code> will
        forward to <code class="code">ErrorController::errorAction()</code> in the default
        module. You may set alternate values for these by using the various
        accessors available to the plugin:
    </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                <code class="code">setErrorHandlerModule()</code> sets the controller module
                to use.
            </p></li>
<li><p>
                <code class="code">setErrorHandlerController()</code> sets the controller
                to use.
            </p></li>
<li><p>
                <code class="code">setErrorHandlerAction()</code> sets the controller action
                to use.
            </p></li>
<li><p>
                <code class="code">setErrorHandler()</code> takes an associative array, which
                may contain any of the keys 'module', 'controller', or 'action',
                with which it will set the appropriate values.
            </p></li>
</ul></div>
<p>
        Additionally, you may pass an optional associative array to the
        constructor, which will then proxy to <code class="code">setErrorHandler()</code>.
    </p>
<p>
        <code class="code">Zend_Controller_Plugin_ErrorHandler</code> registers a
        <code class="code">postDispatch()</code> hook and checks for exceptions registered in
        <a href="zend.controller.response.html" title="7.9. The Response Object">the response object</a>. If
        any are found, it attempts to forward to the registered error handler
        action.
    </p>
<p>
        If an exception occurs dispatching the error handler, the plugin will
        tell the front controller to throw exceptions, and rethrow the last
        exception registered with the response object.
    </p>
<div class="sect4" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.controller.plugins.standard.errorhandler.fourohfour"></a>7.10.5.2.1. Using the ErrorHandler as a 404 Handler</h5></div></div></div>
<p>
            Since the <code class="code">ErrorHandler</code> plugin captures not only
            application errors, but also errors in the controller chain arising
            from missing controller classes and/or action methods, it can be
            used as a 404 handler. To do so, you will need to have your error
            controller check the exception type.
        </p>
<p>
            Exceptions captured are logged in an object registered in the
            request. To retrieve it, use
            <code class="code">Zend_Controller_Action::_getParam('error_handler')</code>:
        </p>
<pre class="programlisting">&lt;?php
class ErrorController extends Zend_Controller_Action
{
    public function errorAction()
    {
        $errors = $this-&gt;_getParam('error_handler');
    }
}
        </pre>
<p>
            Once you have the error object, you can get the type via
            <code class="code">$errors-&gt;type</code>. It will be one of the following:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p>
                    <code class="code">Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_CONTROLLER</code>,
                    indicating the controller was not found.
                </p></li>
<li><p>
                    <code class="code">Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_ACTION</code>,
                    indicating the requested action was not found.
                </p></li>
<li><p>
                    <code class="code">Zend_Controller_Plugin_ErrorHandler::EXCEPTION_OTHER</code>,
                    indicating other exceptions.
                </p></li>
</ul></div>
<p>
            You can then test for either of the first two types, and, if so,
            indicate a 404 page:
        </p>
<pre class="programlisting">&lt;?php
class ErrorController extends Zend_Controller_Action
{
    public function errorAction()
    {
        $errors = $this-&gt;_getParam('error_handler');

        switch ($errors-&gt;type) {
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_CONTROLLER:
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_ACTION:
                // 404 error -- controller or action not found
                $this-&gt;getResponse()-&gt;setRawHeader('HTTP/1.1 404 Not Found');

                // ... get some output to display...
                break;
            default:
                // application error; display error page, but don't change
                // status code
                break;
        }
    }
}
        </pre>
<p>
            Finally, you can retrieve the exception that triggered the error
            handler by grabbing the <code class="code">exception</code> property of the
            <code class="code">error_handler</code> object:
        </p>
<pre class="programlisting">&lt;?php
public function errorAction()
{
        $errors = $this-&gt;_getParam('error_handler');


        switch ($errors-&gt;type) {
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_CONTROLLER:
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_ACTION:
                // 404 error -- controller or action not found
                $this-&gt;getResponse()-&gt;setRawHeader('HTTP/1.1 404 Not Found');

                // ... get some output to display...
                break;
            default:
                // application error; display error page, but don't change
                // status code

                // ...

                // Log the exception:
                $exception = $errors-&gt;exception;
                $log = new Zend_Log(new Zend_Log_Writer_Stream('/tmp/applicationException.log'));
                $log-&gt;debug($exception-&gt;getMessage() . "\n" .  $exception-&gt;getTraceAsString());
                break;
        }
}
        </pre>
</div>
<div class="sect4" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.controller.plugins.standard.errorhandler.buffer"></a>7.10.5.2.2. Handling Previously Rendered Output</h5></div></div></div>
<p>
            If you dispatch multiple actions in a request, or if your action
            makes multiple calls to <code class="code">render()</code>, its possible that the
            response object already has content stored within it. This can lead
            to rendering a mixture of expected content and error content.
        </p>
<p>
            If you wish to render errors inline in such pages, no changes will
            be necessary. If you do not wish to render such content, you should
            clear the response body prior to rendering any views:
        </p>
<pre class="programlisting">&lt;?php
$this-&gt;getResponse()-&gt;clearBody();
        </pre>
</div>
<div class="sect4" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.controller.plugins.standard.errorhandler.examples"></a>7.10.5.2.3. Plugin Usage Examples</h5></div></div></div>
<div class="example">
<a name="zend.controller.plugins.standard.errorhandler.examples.example-1"></a><p class="title"><b>Example 7.16. Standard usage</b></p>
<div class="example-contents"><pre class="programlisting">&lt;?php
require_once 'Zend/Controller/Front.php';
require_once 'Zend/Controller/Plugin/ErrorHandler.php';

$front = Zend_Controller_Front::getInstance();
$front-&gt;registerPlugin(new Zend_Controller_Plugin_ErrorHandler());
            </pre></div>
</div>
<br class="example-break"><div class="example">
<a name="zend.controller.plugins.standard.errorhandler.examples.example-2"></a><p class="title"><b>Example 7.17. Setting a different error handler</b></p>
<div class="example-contents"><pre class="programlisting">&lt;?php
require_once 'Zend/Controller/Front.php';
require_once 'Zend/Controller/Plugin/ErrorHandler.php';

$front = Zend_Controller_Front::getInstance();
$front-&gt;registerPlugin(new Zend_Controller_Plugin_ErrorHandler(array(
    'module'     =&gt; 'mystuff',
    'controller' =&gt; 'static',
    'action'     =&gt; 'error'
)));
            </pre></div>
</div>
<br class="example-break"><div class="example">
<a name="zend.controller.plugins.standard.errorhandler.examples.example-3"></a><p class="title"><b>Example 7.18. Using accessors</b></p>
<div class="example-contents"><pre class="programlisting">&lt;?php
require_once 'Zend/Controller/Front.php';
require_once 'Zend/Controller/Plugin/ErrorHandler.php';

$plugin = new Zend_Controller_Plugin_ErrorHandler();
$plugin-&gt;setErrorHandlerModule('mystuff')
       -&gt;setErrorHandlerController('static')
       -&gt;setErrorHandlerAction('error');

$front = Zend_Controller_Front::getInstance();
$front-&gt;registerPlugin($plugin);
            </pre></div>
</div>
<br class="example-break">
</div>
<div class="sect4" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="zend.controller.plugins.standard.errorhandler.controllerexamples"></a>7.10.5.2.4. Error Controller Example</h5></div></div></div>
<p>
            In order to use the Error Handler plugin, you need an error
            controller. Below is a simple example.
        </p>
<pre class="programlisting">&lt;?php
class ErrorController extends Zend_Controller_Action
{
    public function errorAction()
    {
        $errors = $this-&gt;_getParam('error_handler');

        switch ($errors-&gt;type) {
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_CONTROLLER:
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_ACTION:
                // 404 error -- controller or action not found
                $this-&gt;getResponse()-&gt;setRawHeader('HTTP/1.1 404 Not Found');

                $content =&lt;&lt;&lt;EOH
&lt;h1&gt;Error!&lt;/h1&gt;
&lt;p&gt;The page you requested was not found.&lt;/p&gt;
EOH;
                break;
            default:
                // application error
                $content =&lt;&lt;&lt;EOH
&lt;h1&gt;Error!&lt;/h1&gt;
&lt;p&gt;An unexpected error occurred with your request. Please try again later.&lt;/p&gt;
EOH;
                break;
        }

        // Clear previous content
        $this-&gt;getResponse()-&gt;clearBody();

        $this-&gt;view-&gt;content = $content;
    }
}
        </pre>
</div>
</div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.controller.response.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.controller.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.controller.modular.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">7.9. The Response Object </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> 7.11. Using a Conventional Modular Directory Structure</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
